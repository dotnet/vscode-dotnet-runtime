parameters:
  pool: ''
  SignType: ''
  useOneEngineeringPool: ''

jobs:
  - deployment: PublishToMarketplace
    templateContext:
      type: releaseJob
      isProduction: true
      inputs:
        - input: pipelineArtifact
          artifactName: vscode-dotnet-runtime-extension
          targetPath: $(System.DefaultWorkingDirectory)
          listFiles: true
    pool:
      ${{ parameters.pool }}
    displayName: 'üåê Publish to Marketplace'
    environment: 'vscode-dotnetcore-extension-releases'  # This requires approval gates configured in Azure DevOps
    dependsOn:
    - ${{ parameters.pool.os }}_Package
    strategy:
      runOnce:
        deploy:
          steps:
          - template: install-node.yaml
          - pwsh: |
              Write-Host "====================== FILE STRUCTURE OVERVIEW ======================"
              Write-Host ""

              # Function to create a tree-like structure
              function Show-DirectoryTree {
                param(
                  [string]$Path,
                  [string]$Title,
                  [string]$Prefix = ""
                )

                Write-Host "$Title" -ForegroundColor Cyan
                Write-Host "Path: $Path" -ForegroundColor Yellow
                Write-Host ""

                if (Test-Path $Path) {
                  try {
                    $items = Get-ChildItem -Path $Path -Recurse | Sort-Object FullName
                    $totalFiles = ($items | Where-Object { -not $_.PSIsContainer }).Count
                    $totalDirs = ($items | Where-Object { $_.PSIsContainer }).Count

                    Write-Host "üìä Summary: $totalDirs directories, $totalFiles files" -ForegroundColor Green
                    Write-Host ""

                    # Group by directory for better structure
                    $directories = $items | Where-Object { $_.PSIsContainer } | Sort-Object FullName
                    $files = $items | Where-Object { -not $_.PSIsContainer } | Sort-Object FullName

                    # Show directory structure first
                    if ($directories.Count -gt 0) {
                      Write-Host "üìÅ Directory Structure:" -ForegroundColor Magenta
                      foreach ($dir in $directories) {
                        $relativePath = $dir.FullName.Replace($Path, "").TrimStart('\', '/')
                        $depth = ($relativePath.Split('\', '/') | Where-Object { $_ -ne "" }).Count
                        $indent = "  " * $depth + "‚îú‚îÄ‚îÄ "
                        Write-Host "$indent$($dir.Name)/" -ForegroundColor Blue
                      }
                      Write-Host ""
                    }

                    # Show files grouped by directory
                    Write-Host "üìÑ Files:" -ForegroundColor Magenta
                    $filesByDir = $files | Group-Object { Split-Path $_.FullName -Parent }

                    foreach ($group in ($filesByDir | Sort-Object Name)) {
                      $relativeDirPath = $group.Name.Replace($Path, "").TrimStart('\', '/')
                      if ($relativeDirPath -eq "") {
                        Write-Host "  üìÇ Root:" -ForegroundColor Yellow
                      } else {
                        Write-Host "  üìÇ $relativeDirPath:" -ForegroundColor Yellow
                      }

                      foreach ($file in ($group.Group | Sort-Object Name)) {
                        $size = if ($file.Length -lt 1KB) { "$($file.Length) B" }
                               elseif ($file.Length -lt 1MB) { "{0:N1} KB" -f ($file.Length / 1KB) }
                               else { "{0:N1} MB" -f ($file.Length / 1MB) }

                        Write-Host "    ‚îú‚îÄ‚îÄ $($file.Name) ($size)" -ForegroundColor White
                      }
                      Write-Host ""
                    }
                  }
                  catch {
                    Write-Host "‚ùå Error accessing directory: $_" -ForegroundColor Red
                  }
                } else {
                  Write-Host "‚ùå Directory does not exist" -ForegroundColor Red
                }
                Write-Host "=================================================================" -ForegroundColor Cyan
                Write-Host ""
              }

              # Show System.DefaultWorkingDirectory
              Show-DirectoryTree -Path "$(System.DefaultWorkingDirectory)" -Title "üè† SYSTEM DEFAULT WORKING DIRECTORY"

              # Show Build.ArtifactStagingDirectory
              Show-DirectoryTree -Path "$(Build.ArtifactStagingDirectory)" -Title "üéØ BUILD ARTIFACT STAGING DIRECTORY"

            displayName: 'üìã List All Files Recursively'
          - pwsh: |
              # Extract version from downloaded VSIX filename
              Write-Host "Artifacts directory contents:"
              Get-ChildItem -Path '$(System.DefaultWorkingDirectory)' -Recurse | Format-Table Name, FullName

              $vsixFile = Get-ChildItem -Path '$(System.DefaultWorkingDirectory)' -Recurse -Filter "vscode-dotnet-runtime-*.vsix" | Select-Object -First 1
              if (-not $vsixFile) {
                Write-Error "Could not find VSIX file in artifacts"
                exit 1
              }

              # Extract version from filename (e.g., vscode-dotnet-runtime-1.2.3.vsix -> 1.2.3)
              if ($vsixFile.Name -match 'vscode-dotnet-runtime-(.+)\.vsix$') {
                $version = $matches[1]
                # Handle signed VSIX files (remove -signed suffix if present)
                $version = $version -replace '-signed$', ''
                Write-Host "Extracted version: $version"
                echo "##vso[task.setvariable variable=version;isOutput=true]$version"
              } else {
                Write-Error "Could not extract version from VSIX filename: $($vsixFile.Name)"
                exit 1
              }
            name: GetVersion
            displayName: '‚ùì Extract Version from Artifact'
          - task: AzureCLI@2
            displayName: 'üöÄ Publish to Marketplace'
            inputs:
              azureSubscription: 'VSCode Marketplace Publishing'
              scriptType: "pscore"
              scriptLocation: 'inlineScript'
              workingDirectory: $(System.DefaultWorkingDirectory)
              inlineScript: |
                npm i -g --verbose @vscode/vsce

                # Find the required files using extracted version
                $version = "$(GetVersion.version)"
                Write-Host "Looking for files with version: $version"

                # Find VSIX file (try signed first, then regular)
                $vsixFile = Get-ChildItem -Recurse -Filter "vscode-dotnet-runtime-$version-signed.vsix" | Select-Object -First 1
                if (-not $vsixFile) {
                  $vsixFile = Get-ChildItem -Recurse -Filter "vscode-dotnet-runtime-$version.vsix" | Select-Object -First 1
                }

                $manifestFile = Get-ChildItem -Recurse -Filter "vscode-dotnet-runtime-$version.manifest" | Select-Object -First 1
                $signatureFile = Get-ChildItem -Recurse -Filter "vscode-dotnet-runtime-$version.signature.p7s" | Select-Object -First 1

                if (-not $vsixFile -or -not $manifestFile -or -not $signatureFile) {
                  Write-Error "Could not find required files for version $version"
                  Write-Error "VSIX found: $($vsixFile -ne $null)"
                  Write-Error "Manifest found: $($manifestFile -ne $null)"
                  Write-Error "Signature found: $($signatureFile -ne $null)"

                  Write-Host "Available files:"
                  Get-ChildItem -Recurse | Format-Table Name, FullName
                  exit 1
                }

                Write-Host "Using VSIX file: $($vsixFile.FullName)"
                Write-Host "Using manifest: $($manifestFile.FullName)"
                Write-Host "Using signature: $($signatureFile.FullName)"

                $publishArgs = @(
                  'publish'
                  '--azure-credential'
                  '--packagePath'
                  $vsixFile.FullName
                  '--manifestPath'
                  $manifestFile.FullName
                  '--signaturePath'
                  $signatureFile.FullName
                )

                If ("${{ parameters.SignType }}" -ne "Real") {
                  Write-Host "With a test-signed build, the command to publish is printed instead of run."
                  Write-Host "##[command]vsce $publishArgs"
                }
                Else {
                  Write-Host "##[command]vsce $publishArgs"
                }